% =================================================================
% TEXTO LATEX CORRIGIDO COM TODAS AS REFERÊNCIAS
% =================================================================
% 
% Autor: [Seu Nome]
% Data: 08 Janeiro 2026
% Descrição: Texto da dissertação com citações corrigidas e adicionadas
%
% INSTRUÇÕES:
% 1. Copie este conteúdo para o seu ficheiro LaTeX principal
% 2. Verifique as notas marcadas com [ATENÇÃO] e [VERIFICAR]
% 3. Compile com BibTeX para gerar as referências
%
% =================================================================



% =================================================================
% CAPÍTULO 1: INTRODUÇÃO
% =================================================================
\chapter{Introduction} \label{chap:intro}

This chapter provides a brief introduction to the topic associated with the work carried out during the dissertation period. Firstly, a contextualization is given, followed by a presentation of the research question and the main motivations for carrying out this study. The main objectives of this dissertation will also be outlined, as well as the methodology used to achieve them. Finally, the structure of the dissertation is presented.

We live in an era where smart devices are everywhere, known as the Internet of Things, IoT. While the processing and storage of information are inherently digital, benefiting from the scaling of Moore's Law, the physical world remains fundamentally analogic. Physical variables such as temperature, sound and biological potentials are continuous in both time and amplitude. Consequently, the Analog-to-Digital Converter, ADC, serves as the critical interface bridging these two domains, enabling digital systems to interact with the real world \cite{johns_martin_2012}.

Energy efficiency has shifted from being a secondary performance metric to a primary design constraint, many of the sensors operate on limited battery or rely on energy harvesting, where every Joule of power dissipation has a direct effect on the system's autonomy. In this landscape, the data conversion block almost always takes place as the most spender in this field, especially in sensor interfaces where the digital transmission is duty-cycled.

However, a fundamental characteristic of many environmental and physiological signals is sparsity in between pulses. Signals such as electrocardiograms, voice activity, or environmental monitoring data are spread in bursts in nature: they contain short periods of high information content followed by long intervals of inactivity. 

Traditional data conversion approaches, based on uniform sampling and dictated by the Nyquist-Shannon theorem \cite{shannon_1949}, treat these silence periods with the same computational power and energetic waste as the active periods. This creates a paradigm of inefficiency the system dissipates power to generate redundant digital samples that carry no new information. Recognizing and exploiting this sparsity is the key to unlocking ultra-low-power electronic interfaces.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/time-sparse.png}
  \caption{Time-sparse signal representation and sampling strategies. (a) Time-sparse signal example showing burst activity with periods of inactivity. (b) Continuous-time event-driven sampling and conversion, which responds to signal changes. (c) Conventional uniform sampling operating at fixed Nyquist rate regardless of signal activity. (d) Discrete-time sampling with event-driven conversion, combining periodic and event-based approaches. This illustration demonstrates the efficiency of adaptive sampling methods for sparse signals compared to uniform sampling at the Nyquist rate \cite{lim_2013}.}
  \label{fig:Sparse-time}
\end{figure}

\section{Motivation and Problem Statement} \label{sec:motivation}

The energy waste in massive-scale IoT deployments and the inefficiency of conventional synchronous architectures when processing sparse data shows the need for a fundamental shift toward architectures that activate only when meaningful data events occur.

\subsection{Inefficiency of Synchronous Sampling}

Traditional Analog-to-Digital Converters operate under a fixed-rate sampling rate, dictated by a global clock signal ($f_s$). As established by the Nyquist-Shannon sampling theorem \cite{shannon_1949}, this rate is determined by the maximum possible bandwidth of the signal, $f_s \geq 2B$. However, in many real-world applications, the signal is often active for only a fraction of the time, meaning the true information content is much lower than the theoretical maximum bandwidth suggests.

This leads to a massive waste of energy due to the fundamental relationship governing dynamic power consumption in CMOS circuits \cite{baker_cmos_2010}:
\begin{equation}
  P_{dynamic} = \alpha \cdot f \cdot C_{L} \cdot V_{DD}^2
\end{equation}
where:
\begin{itemize}
  \item $P_{dynamic}$ is the dynamic power dissipated.
  \item $\alpha$ is the activity factor (or switching factor).
  \item $f$ is the clock frequency.
  \item $C_L$ is the load capacitance being switched (e.g., in the clock tree).
\end{itemize}

\subsection{Architectural Problem: Flash ADCs}
While the Flash ADC architecture is highly attractive due to its single-cycle, high-speed conversion capability \cite{johns_martin_2012}, it suffers from severe limitations regarding power and area, particularly when reaching medium-to-high resolution. The number of required comparators scales exponentially with resolution ($2^N$). This exponential scaling leads directly to an increase in input capacitance and static power dissipation.

Even in low-power, synchronous designs, the dynamic power of the comparator switching is the dominant factor in the power budget.

Therefore, combining the high speed of the Flash architecture with the high power efficiency required for IoT demands a radical shift away from the synchronous clocking scheme.

\subsection{Device Limitation: The Mismatch Problem}

To mitigate the power and area issues mentioned above, designers are compelled to minimize the physical dimensions of the core devices, particularly the transistors within the comparators. However, this introduces a fundamental physical constraint:

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{figures/Mismatch error.png}
  \caption{Adapted from \cite{MPScholar}. ADC transfer function illustrating Differential Non-Linearity (DNL) errors. The graph compares the ideal staircase response (blue) with the actual response (red), highlighting varying step widths and a missing code.}
  \label{fig:Offset-error}
\end{figure}

The reduction of transistor size, while increasing speed and reducing capacitance, drastically increases random variations in parameters like the threshold voltage ($V_{th}$), leading to a significant Input Offset Voltage ($V_{os}$) in the comparators \cite{baker_cmos_2010}.
Linearity errors arise from several factors, starting with component mismatches where dnl and inl faults are caused by discrepancies in resistor values within ladders or capacitors in arrays. nonlinearities in analog components such as amplifiers and other parts of the adc also influence these mistakes \cite{MPScholar}. Furthermore, variations in temperature and supply voltage can cause component values to drift, thereby contributing to linearity problems. Finally, fluctuations in the clock signal known as clock jitter cause sampling instances to vary, resulting in linearity issues that are particularly noticeable at higher frequencies.
\section{Objectives and Contribution} \label{sec:objectives}

Based on the limitations identified in traditional synchronous data conversion when dealing with sparse sensor signals, the primary objective of this work is to design and implement an energy-efficient ADC architecture, so this ADC must exploit signal inactivity to achieve a significant reduction in power consumption.

\subsection{Specific Objectives}
To achieve the overall goal of developing an efficient ADC, the following specific objectives are defined for this dissertation:

\begin{enumerate}
  \item Asynchronous Architecture Design: To develop the circuit-level design of an asynchronous Flash ADC, minimizing dynamic power consumption by ensuring that power is only dissipated when an input signal event occurs.
  
  \item Offline Trimming Implementation: To implement an offline trimming mechanism capable of detecting and compensating for the input offset voltage of the comparators.
  \item Mixed-Signal Validation: To validate the complete system through analog and digital co-simulation. This validation must confirm the functionality and accuracy of both the asynchronous core and the trimming logic.
  
  \item Performance Benchmarking: To quantify the energy efficiency of the proposed design using well known figures of merit. The results must be compared against the current state of the art synchronous ADCs and relevant asynchronous solutions.
\end{enumerate}

% =================================================================
% CAPÍTULO 2: REVISÃO DA LITERATURA
% =================================================================
\chapter{Literature Review} \label{chap:lit_review}

This chapter presents the state-of-the-art in Analog-to-Digital Converters, reviewing theoretical foundations and analyzing survey data to justify the proposed architecture.

\section{Fundamentals of Analog-to-Digital Conversion} \label{sec:adc_fundamentals}

This section provides the theoretical background required to understand the operation and performance characterization of data converters. It covers the fundamental steps of the conversion process such as sampling, quantization, and coding.

\subsection{The Data Conversion Process}

\subsubsection{Ideal Data Conversion}
The analog-to-digital conversion process acts as the bridge between the continuous physical world and the discrete digital domain. Conceptually, it involves two distinct operations: discretization in time, sampling, and discretization in amplitude, quantization. Ideally, this process should be instantaneous and lossless within the signal bandwidth of interest \cite{johns_martin_2012}.

\subsubsection{The Sampling Operation}
Sampling converts a continuous-time signal $x(t)$ into a discrete-time sequence $x[n]$ \cite{johns_martin_2012}.

According to the Nyquist-Shannon sampling theorem \cite{shannon_1949}, a band-limited signal with maximum frequency $B$ can be perfectly reconstructed if the sampling frequency $f_s$ satisfies:
\begin{equation}
  f_s \geq 2B
\end{equation}
Violating this condition results in aliasing, where high-frequency spectral components mixes into the baseband, becoming indistinguishable from the original signal \cite{johns_martin_2012}.

\subsubsection{The Quantization Operation}
While sampling transforms continuous time in discrete values, quantization maps the continuous amplitude of each sample to one of a finite number of levels \cite{johns_martin_2012}. An $N$-bit ADC divides the input range ($V_{ref}$) into $2^N$ discrete levels. The step size between adjacent levels is the Least Significant Bit (LSB):
\begin{equation}
  V_{LSB} = \frac{V_{ref}}{2^N}
\end{equation}
Unlike sampling, quantization is non-reversible and introduces a deterministic error. This error is typically modeled as white noise added, the quantization noise with a uniform probability distribution. For an ideal quantizer, the Signal-to-Quantization-Noise Ratio (SQNR) is given by the formula \cite{johns_martin_2012}:
\begin{equation}
  SQNR_{dB} \approx 6.02N + 1.76
\end{equation}

\subsubsection{Coding}
The final stage is encoding the quantized level into a binary format. The choice of coding scheme being the most common straight binary and gray code which depends on the system requirements for data processing and transmission, but does not affect the fundamental analog performance \cite{baker_cmos_2010}.

\subsection{Performance Metrics}

To evaluate and compare different data converters objectively, a standard set of metrics is used \cite{johns_martin_2012}. These are categorized into dynamic and static parameters.

\subsubsection{Resolution and Sampling Rate}
Resolution defines the theoretical dynamic range, while the sampling rate determines the maximum signal bandwidth. However, these are nominal values the actual performance is limited by noise and non-linearities \cite{johns_martin_2012}.

\subsubsection{Signal-to-Noise-Distortion Ratio (SNDR)}
Signal to noise ratio adding distortion ratio or SNDR is the primary dynamic metric \cite{johns_martin_2012}. It is the ratio of the signal power to the total power of all noise and harmonic distortion components. From SNDR, the Effective Number of Bits, ENOB, is derived \cite{johns_martin_2012}:
\begin{equation}
  ENOB = \frac{SNDR_{dB} - 1.76}{6.02}
\end{equation}
This value represents the true resolution of the converter at a specific input frequency.

\subsubsection{Differential and Integral Non-Linearity (DNL and INL)}
Static linearity is characterized by measuring the deviation of code transition levels from their ideal positions \cite{johns_martin_2012}. The DNL measures the deviation of a single step width from the ideal 1 LSB. A DNL less than -1 LSB implies a missing code in the transfer function.

The INL is the cumulative sum of DNL errors, representing the deviation of the transfer curve from a straight line. Specific INL patterns like saw-tooth shapes can reveal systematic errors in the architecture, such as gain mismatch or non-linear biasing \cite{van_de_plassche_1994}.

\subsubsection{Offset and Gain Error}
These are linear errors, offset is a constant shift of the transfer characteristic as seen before in section 1.2.3, while gain error is a deviation in the slope \cite{johns_martin_2012}. Unlike non-linearity, these errors preserve the signal shape and can often be calibrated out simply.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/offset_error.png} 
  \caption{ADC transfer function showing offset and gain errors. Offset error represents a constant DC shift applied uniformly across all codes, while gain error modifies the slope of the transfer function. Both are linear errors that can be calibrated using digital post-processing techniques \cite{johns_martin_2012}.}
  \label{fig:offset_gain_error}
\end{figure}

\subsubsection{Bit Error Rate (BER)}
BER quantifies the probability of the converter producing an incorrect digital code \cite{baker_cmos_2010}. This is often caused by metastability, a phenomenon where internal decision circuits fail to resolve a valid logic level within the allocated time when the input is extremely close to a decision threshold.

\subsection{State-of-the-Art Comparative Analysis} \label{sec:sota_analysis}

The analytical plots and tables presented below incorporate data from an exhaustive set of 140 state-of-the-art works. To ensure transparency and reproducibility, the complete list of references used to generate these performance envelopes covering Flash, SAR, Pipeline, and Sigma-Delta architectures is provided in \cite{ALCoban_1999_113,AbhishekAgrawal_2023_100,AmyWhitcombe_2024_101,AnandSubramanian_2024_143,BGregoire_2008_25,BMalkietal_2012_47,Balmelli_2004_119,BenjaminHershberg_2019_30,BramVeraverbeke_2025_91,Breems_2007_130,CCLiu_2010_45,CHChan_2015_57,CHammerschmied_1997_39,CPochet_2022_110,CYLee_2022_140,CYLiouetal_2013_50,ChengChungHsu_2007_24,ChengEnHsieh_2025_93,ChiYunStanleyWang_2019_138,ChinYuLin_2016_61,Christen_2007_131,ChunChengLiu_2016_60,Dezzani_2003_116,Dorrer_2005_124,EJanssenetal_2013_51,EwoutMartens_2024_96,FMYaul_2014_54,FMichel_2011_134,FengChen_2003_115,Fontaine_2005_125,Fujimoto_2006_129,Gaggl_2004_121,Geelen_2006_19,GeunhaKim_2023_77,GianHoogzaadandRafRoovers_1999_6,Goes_2006_128,GovertGeelenandEdwardPaulus_2004_7,HHBoo_2015_29,HKHong_2015_58,HWei_2011_46,HZhao_2022_68,HanZhao_2025_87,HendrikvanderPloegandRobertRemmers_1999_105,Hesener_2007_41,HongshuaiZhang_2023_71,HongzhiZhao_2023_73,Huber_2007_108,HwiCheolKim_2005_18,JCWang_2022_66,JLiu_2022_98,JaewonLee_2025_102,JiaChingWang_2023_97,JiangYu_2005_122,JianxiongXu_2025_1,JihangGao_2025_88,JinseokKoh_2005_123,JongmiLee_2024_144,JosephInginoJrandBruceWooley_1998_9,JunhuaShen_2025_94,JunlinZhong_2025_103,JunyanHao_2023_32,KBult_1997_4,KaiChengCheng_2024_82,KentaroYoshioka_2017_62,KyeongwonJeong_2025_86,KyojinDChoo_2016_59,LiangQi_2019_137,MDing_2015_56,MFlynn_1998_5,MYoshioka_2010_44,MZhan_2022_67,ManxinLi_2023_70,MingleiZhang_2019_63,MingtaoZhan_2023_75,MingyangGu_2025_36,Mitteregger_2006_126,Ong_1997_112,PHarpe_2014_53,PHarpe_2015_55,PHarpeetal_2012_48,PHarpeetal_2013_49,PSchvan_2006_3,PSchvan_2008_42,PatrickVogelmann_2018_135,QLiu_2022_141,RKapustaetal_2013_52,RaresBodnar_2024_83,Ray_2006_20,SUKwak_1997_8,SandeepSanthoshKumar_2023_74,SangheonLee_2024_78,Senderowicz_1997_111,SerdarAbdullahYonar_2023_99,SeungChulLee_2007_23,SewonLee_2024_84,SharvilPatil_2024_35,ShengJuiHuang_2009_133,Shimizu_2006_107,SiddharthDevarajan_2009_26,Silva_2006_127,SiyuanYe_2024_95,SiyuanYe_2025_89,SungEnHsieh_2023_31,TKang_2022_142,TWang_2022_69,Tabatabaei_2003_118,Verma_2006_40,Vleugels_2001_114,WLiu_2010_43,Waltari_2002_12,Wang_2005_16,XiyuHe_2024_80,YCHuang_2010_27,YChae_2008_132,YChaietal_2012_28,YHu_2022_139,YSegal_2022_65,YShimizu_2008_109,Yan_2003_117,YanboZhang_2023_72,YannanZhang_2025_92,Yao_2004_120,YaohuiLuan_2025_145,YiHuWang_2023_76,YingZuLin_2019_64,YongLim_2024_79,Yoshioka_2005_17,Yoshioka_2007_21,YoungDeukJeon_2007_22,YueCao_2025_37,YuefengCao_2023_33,YuefengCao_2024_34,YukoTambaandKazuoYamakido_1999_2,YunsongTao_2024_85,YunsongTao_2025_38,ZhuoyiChen_2024_81,ZhuoyiChen_2025_90,ZijianLiu_2025_104}. Collectively, these works represent the proven performance frontier across all major ADC architectures.

\par\vspace{1.5em}
\par\vspace{1.5em}
\par\vspace{1.5em}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.85\textwidth]{fom_fs.png}
    \caption{Walden FoM vs. Sampling Rate ($f_s$).}
    \label{fig:fom_fs}
\end{figure}

\par\vspace{1.5em}
\par\vspace{1.5em}
\par\vspace{1.5em}

\begin{table}[htbp]
\centering
\caption{Walden FoM vs. Sampling Frequency (Flash reference [1] highlighted)}
\label{tab:fom_fs}
\begin{tabular}{lllc}
\toprule
\textbf{Ref.} & \textbf{Architecture} & \textbf{Publication} & \textbf{$f_s$ [Hz]} \\ \midrule
\textbf{[1]}  & \textbf{Flash}       & \textbf{Lukas \cite{Lukas_2014}} & \textbf{20G} \\
{} [2]        & SAR                  & Jang \cite{Jang_2018}            & 270k \\
{} [3]        & SAR                  & Ginsburg \cite{Ginsburg_2014}    & 200k \\
{} [4]        & SAR                  & Cano \cite{De_Cano_Garcia_2019}  & 20M  \\
{} [5]        & SAR                  & Muller \cite{Muller_2015}        & 200  \\ \bottomrule
\end{tabular}
\end{table}

\par\vspace{1.5em}
\par\vspace{1.5em}
\par\vspace{1.5em}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.85\textwidth]{snr_fs.png}
    \caption{SNDR vs. Sampling Frequency ($f_s$) comparison.}
    \label{fig:snr_fs}
\end{figure}

\par\vspace{1.5em}
\par\vspace{1.5em}
\par\vspace{1.5em}

\begin{table}[htbp]
\centering
\caption{SNDR vs. Sampling Frequency (Flash reference [1] highlighted)}
\label{tab:snr_fs}
\begin{tabular}{lllc}
\toprule
\textbf{Ref.} & \textbf{Architecture} & \textbf{Publication} & \textbf{SNDR [dB]} \\ \midrule
\textbf{[1]}  & \textbf{Flash}       & \textbf{Draxelmayr \cite{Draxelmayr_2014}} & \textbf{37.4} \\
{} [2]        & Sigma-Delta          & Delic \cite{Delic-Ibus_2013}          & 120.0 \\
{} [3]        & Sigma-Delta          & Jang \cite{Jang_2018_2}               & 118.0 \\
{} [4]        & Sigma-Delta          & Abe \cite{Abe_2016}                   & 116.0 \\
{} [5]        & Sigma-Delta          & Geelen \cite{Geelen_1997}             & 110.0 \\ \bottomrule
\end{tabular}
\end{table}

\section{Synchronous Architectures} \label{sec:sync_arch}

To address asynchronous ADCs we first need to address synchronous ADCs, they have a global clock signal that dictates sampling instances and synchronizes internal operations. While these architectures are highly mature and widely used, they face fundamental power efficiency trade-offs, particularly when operating at high frequencies or processing sparse data \cite{johns_martin_2012}.

\subsection{Synchronous Flash ADC}
The Flash ADC is conceptually the simplest and fastest architecture, performing a complete conversion in a single clock cycle \cite{baker_cmos_2010}. It utilizes a resistive ladder to generate $2^N-1$ reference voltages, which are compared simultaneously to the input signal by a large bank of comparators. This parallel comparison produces a thermometer code, that a digital logic block then converts into a standard binary output. Its primary limitation is the exponential increase in hardware complexity, area, and power consumption as resolution increases.

The thermometer term refers to the parallel output from the Flash ADC comparators, where '1's run up to the input voltage level like mercury in a thermometer, indicating signal strength before being converted to standard binary by an encoder.

\subsection{The Power Bottleneck}
The primary drawback of the synchronous Flash architecture is its exponential scaling. Survey data clearly illustrates that high speed translates into high power in these designs. For example, a 6-bit 500 MS/s CMOS Flash ADC reported in 1999 already consumed 400 mW \cite{Tamba}. 

% [VERIFICAR]: O texto original menciona 3W mas o Excel indica 1.2W para Schvan_2006
More extreme cases, such as a 22 GS/s 5-bit design, can consume up to 1.2 W \cite{Schvan_2006}.

The continuous clocking of a massive comparator bank creates a significant energy dissipation even when the input signal is static. This lack of adaptivity makes synchronous Flash architectures increasingly unsuitable for battery-powered or energy-harvesting applications.

\subsection{SAR (Successive Approximation Register)}
The SAR ADC operates using a binary search algorithm \cite{van_de_plassche_1994}, for each sample the internal logic tests one bit at a time, starting from the most significant bit (MSB). A single comparator compares the input to the output of an internal digital to analog converter (DAC), if the input is higher, the bit is set to '1' otherwise, it is set to '0'. This process repeats for $N$ cycles. Because it uses very few active components, it is the most energy efficient choice for low speeds.

\begin{figure}[htbp]
\centering % Centers the figure
% \resizebox scales the tikzpicture to fit the textwidth exactly
\resizebox{\textwidth}{!}{ 
    \begin{tikzpicture}
      % Paths, nodes and wires:
      \draw (1, 8) to[amp] (3, 8);
      \node[shape=rectangle, draw, line width=1pt, minimum width=3.715cm, minimum height=0.965cm] at (10.875, 9.5){};
      \node[shape=rectangle, draw, line width=1pt, minimum width=2.965cm, minimum height=2.965cm] at (10.875, 6.625){};
      \draw (5, 5.75) to[dac] (6, 5.75);
      \draw (6, 7.75) -- (5.5, 7.75) -- (5.5, 7.25) -- (5, 7.25) -- (5.5, 7.25);
      \draw (5.25, 7.5) -- (5.75, 7.5);
      \node[shape=rectangle, minimum width=0.436cm, minimum height=0.465cm] at (1.568, 8.142){} node[anchor=north west, align=left, text width=0.048cm, inner sep=6pt] at (1.332, 8.392){SHA};
      \node[shape=rectangle, minimum width=2.215cm, minimum height=0.215cm] at (10.875, 9.625){} node[anchor=north, align=center, text width=1.827cm, inner sep=6pt] at (10.875, 9.75){Timing};
      \node[shape=rectangle, minimum width=2.715cm, minimum height=1.715cm] at (10.875, 6.75){} node[anchor=north west, align=left, text width=2.327cm, inner sep=6pt] at (9.5, 7.625){Control logic:\\Successive approximation register (SAR)};
      \node[plain amp] at (5.69, 7.51){};
      \draw (3, 8) -- (4.5, 8);
      \draw (4.5, 7.02) -| (4.125, 5.75) -- (5, 5.75);
      \draw[-latex] (4.5, 8) -- (4.875, 8);
      \draw[-latex] (4.125, 7.02) -- (4.5, 7.02);
      \draw (9, 9.5) -- (2, 9.5) |- (2, 8.269);
      \draw[-latex] (2, 9.5) -- (2, 8.269);
      \draw[-latex] (10.875, 9) -- (10.875, 8.125);
      \node[shape=rectangle, minimum width=3.34cm, minimum height=0.465cm] at (15.25, 10){} node[anchor=north west, align=left, text width=2.952cm, inner sep=6pt] at (13.563, 10.25){Convert Start};
      \draw[-latex] (13.562, 9.875) -- (12.75, 9.875);
      \node[shape=rectangle, minimum width=4.09cm, minimum height=0.465cm] at (15.625, 9.25){} node[anchor=north west, align=left, text width=3.702cm, inner sep=6pt] at (13.562, 9.5){EOC, DRDY, Or Busy};
      \draw[-latex] (13.562, 9.25) -- (12.75, 9.25);
      \draw[-latex] (6.88, 7.51) -- (9.375, 7.5);
      \draw[-latex] (9.375, 5.75) -- (6, 5.75);
      \draw[-latex] (7.75, 5.75) -- (7.75, 4.75);
      \node[shape=rectangle, minimum width=0.84cm, minimum height=0.09cm] at (7.437, 4.688){} node[anchor=north west, align=left, text width=0.452cm, inner sep=6pt] at (7, 4.75){Output};
      \node[shape=rectangle, minimum width=0.84cm, minimum height=0.34cm] at (0.187, 8.438){} node[anchor=north west, align=left, text width=1.2cm, inner sep=2pt] at (-0.4, 8.625){Analog input};
      \node[shape=rectangle, minimum width=1.84cm, minimum height=0.465cm] at (6.438, 8.5){} node[anchor=north west, align=left, text width=1.452cm, inner sep=6pt] at (5.5, 8.75){Comparator};
    \end{tikzpicture}
}
\caption{Successive Approximation Register (SAR) ADC architecture showing the sample-and-hold amplifier (SHA), comparator, digital-to-analog converter (DAC), and control logic. The SAR logic iteratively approximates the input signal by testing each bit from MSB to LSB, achieving high energy efficiency at moderate speeds \cite{van_de_plassche_1994}.}
\label{fig:sar_arch}
\end{figure}

\subsection{Pipeline}
The Pipeline ADC breaks the conversion into several sequential stages \cite{johns_martin_2012}, each stage resolves a few bits of information, quantizes them, and passes the remaining error, the residue, to the next stage after amplification. This approach allows the ADC to work on multiple samples concurrently, obtaining very high throughput and high resolution, the problem relies in the inherent processing latency.

\begin{figure}[htbp]
  \centering
  % Resizebox scales the diagram to exactly the text width
  \resizebox{\textwidth}{!}{ 
  \begin{tikzpicture}
  % Paths, nodes and wires:
  \node[shape=rectangle, draw, line width=1pt, minimum width=2.965cm, minimum height=0.84cm] at (1.75, 10.562){};
  \node[shape=rectangle, minimum width=2.465cm, minimum height=0.465cm] at (1.75, 10.625){} node[anchor=north, align=center, text width=2.077cm, inner sep=6pt] at (1.75, 10.875){Stage 1};
  
  \node[shape=rectangle, draw, line width=1pt, minimum width=2.965cm, minimum height=0.84cm] at (5.125, 10.562){};
  \node[shape=rectangle, minimum width=2.465cm, minimum height=0.465cm] at (5.125, 10.625){} node[anchor=north, align=center, text width=2.077cm, inner sep=6pt] at (5.125, 10.875){Stage 2};
  
  \node[shape=rectangle, draw, line width=1pt, minimum width=2.965cm, minimum height=0.84cm] at (8.5, 10.562){};
  \node[shape=rectangle, minimum width=2.465cm, minimum height=0.465cm] at (8.5, 10.625){} node[anchor=north, align=center, text width=2.077cm, inner sep=6pt] at (8.5, 10.875){Stage 3};
  
  \node[shape=rectangle, draw, line width=1pt, minimum width=2.965cm, minimum height=0.84cm] at (11.875, 10.562){};
  \node[shape=rectangle, minimum width=2.465cm, minimum height=0.465cm] at (11.875, 10.625){} node[anchor=north, align=center, text width=2.077cm, inner sep=6pt] at (11.875, 10.875){Stage 4};
  
  \draw (13.375, 10.562) to[adc] (15.125, 10.562);
  
  \node[shape=rectangle, draw, line width=1pt, minimum width=15.715cm, minimum height=0.465cm] at (8.125, 9){};
  \node[shape=rectangle, minimum width=15.215cm, minimum height=0.465cm] at (8.125, 9.125){} node[anchor=north, align=center, text width=14.827cm, inner sep=6pt] at (8.125, 9.375){Time Alignment \& Digital Error Correction};
  
  \draw[-latex] (15.125, 10.562) -- (15.125, 9.25);
  \draw[-latex] (11.875, 10.125) -- (11.875, 9.25);
  \draw[-latex] (8.5, 10.125) -- (8.5, 9.25);
  \draw[-latex] (5.125, 10.125) -- (5.125, 9.25);
  \draw[-latex] (1.75, 10.125) -- (1.75, 9.25);
  
  \draw[-latex] (-1.125, 10.5) -- (0.25, 10.5);
  \node[shape=rectangle, minimum width=1.59cm, minimum height=0.59cm] at (-2.063, 10.562){} node[anchor=north, align=center, text width=1.202cm, inner sep=6pt] at (-2.063, 10.875){Vin};
  
  \draw[-latex] (3.25, 10.562) -- (3.625, 10.562);
  \draw[-latex] (6.625, 10.562) -- (7, 10.562);
  \draw[-latex] (10, 10.562) -- (10.375, 10.562);
  
  \draw (1.5, 9.5) -- (2, 9.75);
  \draw[-latex] (5.125, 10.125) -- (5.125, 9.25);
  \draw (4.875, 9.5) -- (5.375, 9.75);
  \draw[-latex] (8.5, 10.125) -- (8.5, 9.25);
  \draw (8.25, 9.5) -- (8.75, 9.75);
  \draw[-latex] (11.875, 10.125) -- (11.875, 9.25);
  \draw (11.625, 9.5) -- (12.125, 9.75);
  \draw[-latex] (8.125, 8.75) -- (8.125, 7.875);
  \draw (7.875, 8.125) -- (8.375, 8.375);
  
  % Fixed labels "3"
  \node[shape=rectangle, minimum width=0.465cm, minimum height=0.215cm] at (2.375, 9.75){} node[anchor=north west, inner sep=2pt] at (2.125, 9.875){3};
  \node[shape=rectangle, minimum width=0.465cm, minimum height=0.369cm] at (5.75, 9.75){} node[anchor=north west, inner sep=2pt] at (5.5, 9.952){3};
  \node[shape=rectangle, minimum width=0.465cm, minimum height=0.215cm] at (9.125, 9.75){} node[anchor=north west, inner sep=2pt] at (8.875, 9.875){3};
  \node[shape=rectangle, minimum width=0.465cm, minimum height=0.215cm] at (12.5, 9.75){} node[anchor=north west, inner sep=2pt] at (12.25, 9.875){3};
  
  \draw (14.875, 9.5) -- (15.375, 9.75);
  
  % Fixed label "4"
  \node[shape=rectangle, minimum width=0.465cm, minimum height=0.465cm] at (15.75, 9.625){} node[anchor=north west, inner sep=2pt] at (15.5, 9.875){4};
  
  % Fixed label "12" (Removed text width to prevent Overfull hbox)
  \node[shape=rectangle, minimum width=0.84cm, minimum height=0.465cm] at (9.063, 8.25){} node[anchor=north west, inner sep=2pt] at (8.625, 8.5){12};
  \end{tikzpicture}
  }
  \caption{Pipeline ADC architecture showing multiple conversion stages operating in parallel on different input samples. Each stage resolves a portion of the bits and amplifies the residual error to the next stage. The pipelined structure enables high-throughput operation at the expense of increased latency and circuit complexity \cite{johns_martin_2012}.}
  \label{fig:pipeline_arch}
\end{figure}
\paragraph{}
\paragraph{}
\paragraph{}
\subsection{Sigma-Delta ($\Sigma\Delta$)}
The $\Sigma\Delta$ architecture relies on oversampling, sampling much faster than the Nyquist rate \cite{candy_1985}, and noise-modulation. A modulator integrates the difference between the input signal and a feedback version of the quantized output. This process pushes the quantization noise into higher frequencies, outside the signal band of interest, a digital filter then removes the high-frequency noise, resulting in high resolution and precision \cite{schreier_2005}.

\begin{figure}[htbp]
\centering
\resizebox{\textwidth}{!}{ 
    \begin{tikzpicture}[
        % Estilos globais
        node distance=1.0cm and 1.2cm,
        >={Latex[length=4pt, width=3pt]},
        thick,
        font=\small,
        % Estilos personalizados
        block/.style = {draw, rectangle, minimum height=3em, minimum width=3.5em, align=center, fill=white},
        sum/.style = {draw, circle, inner sep=0pt, minimum size=0.6cm, fill=white},
        % Estilo Op Amp (Triângulo)
        my_opamp/.style = {draw, regular polygon, regular polygon sides=3, shape border rotate=-90, minimum height=4em, minimum width=4em, fill=white, inner sep=0pt}
    ]

    % --- 1. Entrada e Somador ---
    \node (vin) at (0,0) {$V_{in}$};

    \node[sum, right=0.8cm of vin] (summer) {\large $\Sigma$};
    \node[above left=-2pt] at (summer.west) {\tiny $+$};
    \node[below left=-2pt] at (summer.south) {\tiny $-$};
    
    % Seta de Vin para o Somador
    \draw[->] (vin) -- (summer);

    % --- 2. Integrador ---
    \node[my_opamp, right=0.8cm of summer, label={above:\scriptsize Integrator}] (integrator) {};
    \node at (integrator.center) {\large $\int$};
    
    % Seta do Somador para o Integrador
    \draw[->] (summer) -- (integrator);

    % --- 3. Comparador ---
    \node[my_opamp, right=1.5cm of integrator] (comparator) {};
    \node[font=\tiny] at ($(comparator.west)+(0.25, 0.25)$) {$+$};
    \node[font=\tiny] at ($(comparator.west)+(0.25, -0.25)$) {$-$};
    
    % Clock e Texto do Comparador
    \draw[<-] ($(comparator.north)!0.5!(comparator.east)$) -- ++(0, 0.5) node[above, font=\scriptsize] {Clock $Kf_s$};
    \node[below=0.2cm, align=center, font=\scriptsize] at (comparator.south) {Latched\\Comparator\\(1-Bit ADC)};

    % --- 4. Filtro Digital ---
    \node[block, right=1.2cm of comparator, minimum height=5em, minimum width=5em] (filter) {Digital\\filter \&\\decimator};
    \draw[<-] (filter.north) -- ++(0, 0.6) node[above, font=\scriptsize] {$f_s$};

    \node[right=1.0cm of filter] (vout) {N-Bits};
    \draw[->] (filter.east) -- (vout) node[midway, below, font=\scriptsize] {$f_s$};
    \draw[thick] ($(filter.east)+(0.5,-0.15)$) -- ++(0.15, 0.3); 

    % --- 5. Feedback Loop & 1-BIT DAC ---
    
    % Posição central do DAC
    \coordinate (dac_center) at ($(integrator.east)!0.5!(comparator.west) + (-1.2, -2.5)$);
    
    % Caixa do DAC
    \draw[thick, fill=white] 
        ($(dac_center)+(-0.6,0)$) --       
        ($(dac_center)+(-0.3,0.6)$) --     
        ($(dac_center)+(0.6,0.6)$) --      
        ($(dac_center)+(0.6,-0.6)$) --     
        ($(dac_center)+(-0.3,-0.6)$) --    
        cycle;

    % Componente SPDT (Interruptor)
    \node[spdt, scale=0.9, transform shape] (sw) at (dac_center) {};

    % Ligações de Vref
    \draw (sw.out 1) -- ++(0, 0.35) node[above, font=\scriptsize] {$+V_{ref}$};
    \draw (sw.out 2) -- ++(0, -0.35) node[below, font=\scriptsize] {$-V_{ref}$};

    % (REMOVIDO o nó isolado que estava aqui antes)


    % --- 6. Ligações do Loop ---
    
    % Integrador -> Comparador
    \draw[->] (integrator.east) -- ++(0.2,0) |- ($(comparator.west)+(0, 0.3)$);
    % Ground do Comparador
    \draw ($(comparator.west)+(0, -0.3)$) -- ++(-0.2, 0) node[ground, scale=0.8] {}; 

    % Saída do Comparador -> Filtro
    \coordinate (feedback_tap) at ($(comparator.east)+(0.6,0)$);
    \draw (comparator.east) -- (feedback_tap);
    \draw[->] (feedback_tap) -- (filter.west);

    % Feedback path
    \draw[->] (feedback_tap) |- ($(dac_center)+(0.6, 0)$) 
        node[near end, above=2pt, align=center, font=\scriptsize, xshift=2.8cm] {1-Bit data\\stream};
    
    % Saída do DAC -> Somador (COM TEXTO 1-BIT DAC AQUI)
    % A linha desenha-se horizontalmente até à coordenada X do somador, e depois sobe.
    % O nó de texto é colocado "midway" (a meio) da parte horizontal, "below" (em baixo).
    \draw[->] (sw.in) -- node[midway, below, font=\scriptsize, align=center] {1-Bit\\DAC} (summer.south |- sw.in) -- (summer.south);


    % --- 7. Caixa do Modulador Sigma-Delta ---
    \draw[dashed, darkgray, line width=0.8pt] 
        ($(summer.north west)+(-0.3, 1.2)$) rectangle 
        ($(comparator.east)+(0.4, -4.0)$); 
        
    \node[below, font=\sffamily\bfseries\scriptsize, darkgray] at ($(dac_center)+(0.5,-1.8)$) {Sigma-Delta Modulator};

    \end{tikzpicture}
}
\caption{First-order Sigma-Delta ADC architecture.}
\label{fig:sigma_delta_arch}
\end{figure}

\subsection{Dual-slope}
This integrating architecture \cite{microelectronics_1998} measures the time required for a capacitor to charge and discharge, in the first phase, the capacitor is charged by the input voltage for a fixed period then for the second phase, it is discharged by a known reference voltage. The time it takes to return to zero is proportional to the average value of the input signal it's highly accurate and immune to high-frequency noise but is much slower than other architectures.

\begin{figure}[htbp]
  
  
  \centering
  % This command scales the picture to exactly the text width
  % The "!" keeps the aspect ratio correct
  \resizebox{\textwidth}{!}{%
  \begin{tikzpicture}
      % Paths, nodes and wires:
      \node[spdt, xscale=-1] at (1.72, 11){};
      \draw (2.315, 11) to[american resistor] (4.625, 11);
      \node[op amp] at (5.815, 10.51){};
      \node[ground] at (4.625, 10.02){};
      \draw (4.625, 12.875) to[capacitor] (7, 12.875);
      \draw (4.625, 14) to[cute closing switch] (7, 14);
      \draw (4.625, 14) -| (4.625, 12.875);
      \draw (7, 14) -- (7, 12.875);
      \draw (4.625, 11) -| (4.625, 12.875);
      \draw (7, 12.875) |- (7.005, 10.51);
      \node[op amp, yscale=-1] at (9.19, 10.02){};
      \draw (8, 10.5) |- (7, 10.51);
      \node[ground] at (8, 9.53){};
      \draw (8.75, 9.75) -- (9, 9.75) -- (9, 10.25) -- (9.25, 10.25);
      \node[shape=rectangle, draw, line width=1pt, minimum width=2.34cm, minimum height=0.965cm] at (5.812, 15.875){};
      \node[shape=rectangle, minimum width=2.34cm, minimum height=0.965cm] at (5.812, 15.75){} node[anchor=north, align=center, text width=1.952cm, inner sep=6pt] at (5.812, 16.25){Control};
      \draw (4.625, 15.75) |- (1.625, 15.75) -| (1.625, 11.375);
      \draw[-latex] (1.625, 15.75) -- (1.625, 11.25);
      \draw[-latex] (5.75, 15.375) -- (5.75, 14.5);
      \node[shape=rectangle, draw, line width=1pt, minimum width=3.84cm, minimum height=3.34cm] at (13.938, 11.312){};
      \node[shape=rectangle, minimum width=0.965cm, minimum height=0.59cm] at (12.625, 12.312){} node[anchor=north west, align=left, text width=0.577cm, inner sep=6pt] at (12.125, 12.625){Clock};
      \node[shape=rectangle, minimum width=1.34cm, minimum height=0.465cm] at (12.813, 10.125){} node[anchor=north west, align=left, text width=0.952cm, inner sep=6pt] at (12.125, 10.375){Gate};
      \node[shape=rectangle, minimum width=1.09cm, minimum height=0.715cm] at (14.875, 11.25){} node[anchor=north west, align=left, text width=0.702cm, inner sep=6pt] at (14.312, 11.625){Digital counter};
      \draw[line width=3.3pt, -latex] (15.875, 11.125) -- (17.625, 11.125);
      \draw[-latex] (10.38, 10.02) -- (12.005, 10.02);
      \node[shape=rectangle, draw, line width=1pt, minimum width=1.715cm, minimum height=1.09cm] at (10.125, 13.313){};
      \node[shape=rectangle, minimum width=1.715cm, minimum height=1.09cm] at (10.125, 13.125){} node[anchor=north, align=center, text width=1.327cm, inner sep=6pt] at (10.125, 13.688){Clock};
      \draw (11, 13.25) -- (11.5, 13.25) -| (11.5, 12.375) -- (12, 12.375);
      \draw (11.5, 13.25) -- (11.5, 15.875) |- (7, 15.875);
      \draw[-latex] (7.75, 15.875) -- (7, 15.875);
      \draw[-latex] (11.5, 12.375) -- (12, 12.375);
      \node[anchor=east] at (0.25, 11.25) {Analog input};

% Voltage Reference Label - Aligned to the left of the wire start (0.25, 10.625)
    \node[anchor=east] at (0.25, 10.625) {Voltage reference}; 
      \draw (1.125, 11.315) -| (0.25, 11.25);
      \draw (1.125, 10.685) -| (0.25, 10.625);
  \end{tikzpicture}
  } % End of resizebox
  
  \caption{Dual-slope (integrating) ADC architecture showing the charging phase where an unknown input signal is integrated for a fixed time, and the discharge phase where a precise reference voltage drives the capacitor back to zero. The conversion time is proportional to the input voltage, providing excellent accuracy and noise rejection at the expense of low throughput \cite{microelectronics_1998}.}
  \label{fig:dual_slope_arch}
\end{figure}

\section{Asynchronous Architectures} \label{sec:async_arch}

Asynchronous, or event-driven, architectures represent a fundamental paradigm shift in data conversion \cite{lim_2013}, unlike synchronous ADCs, which are bound by a global clock and the Nyquist-Shannon sampling theorem, asynchronous ADCs operate based on the signal's activity. This approach offers a more efficient alternative for processing sparse signals.

\subsection{Level-Crossing Sampling (LCS)}
The core principle behind many asynchronous ADCs is Level-Crossing Sampling (LCS) \cite{lim_2013}. In traditional uniform sampling, the signal is captured at fixed time intervals ($T_s$), and the amplitude is quantized. In LCS, the process is inverted: the amplitude levels are fixed (quantization thresholds), and the ADC records the exact time at which the input signal crosses these thresholds.

This method is particularly powerful for signals that remain constant or change slowly over long periods. Instead of generating redundant samples that capture no new information, the LCS ADC remains idle, only producing a digital event when the signal effectively changes by more than the defined threshold.

\subsection{Asynchronous Flash ADC}
The Asynchronous Flash ADC adapts the parallel structure of a standard Flash ADC but removes the sampling clock entirely. In this architecture, the comparators are not latched by a clock, they operate in continuous time, constantly monitoring the input voltage $V_{in}$ against the reference ladder.
The event generation happens when the input signal crosses a threshold, the corresponding comparator changes its output state immediately, this transition triggers an asynchronous logic to generate a digital output pulse.

\section{Calibration and Trimming Techniques} \label{sec:calibration}

In high-speed Flash ADCs, the accuracy of the system is fundamentally limited by the precision of the comparators. While the architecture fundamentals were established in the previous sections, practical implementations must address the non-idealities of the fabrication process, specifically the Input Offset Voltage ($V_{os}$).

\subsection{The Component Mismatch Problem}
In deep sub-micron CMOS technologies, transistors that are drawn with identical dimensions on the layout will exhibit slight differences in their electrical parameters after fabrication. This phenomenon, known as mismatch, affects the threshold voltage ($V_{th}$) and the current gain factor ($\beta$) of the differential pair in a comparator \cite{baker_cmos_2010}.

According to Pelgrom's Law cited in section 2.3.3 of \cite{johns_martin_2012}, the standard deviation of the threshold voltage mismatch ($\sigma_{Vth}$) is inversely proportional to the square root of the transistor area ($W \cdot L$):

\begin{equation}
  \sigma_{V_{th}} = \frac{A_{V_{th}}}{\sqrt{W \cdot L}}
\end{equation}

Where $A_{V_{th}}$ is a technology-dependent constant. This creates a critical trade-off, to minimize offset without calibration, transistors must be made large, which increases parasitic capacitance and degrades the ADC speed and power efficiency. Therefore, small transistors are used for speed, and calibration is needed to correct the resulting offset.

\subsection{Calibration Classifications}
Calibration techniques can be broadly categorized by their timing and domain \cite{baker_cmos_2010}. In terms of timing there can be derived two types foreground calibration which interrupts normal operation to measure and correct errors and background calibration which operates continuously but adds significant complexity.
In terms of domain there is digital calibration that corrects the output code mathematically, whereas analog calibration adjusts the circuit biasing or load conditions to nullify the offset at the source.

For an asynchronous architecture, avoiding continuous clock activity is crucial to maintain low power during idle periods. Thus, Analog Foreground Calibration is the preferred approach.

\subsection{Resistive Trimming Techniques}
Resistive trimming aims to compensate for the imbalance in the input differential pair ($M_1, M_2$) by intentionally creating an opposing imbalance in the load resistance or the reference path \cite{baker_cmos_2010}.

\subsubsection{Internal Resistive Loading}
The internal resistive loading method involves placing a variable resistive network in parallel or series with the output loads of the comparator pre-amplifier stage. By digitally switching small resistors or MOS switches operating in the triode region in parallel with the load branch, the effective resistance $R_L$ is modulated. Since the gain of the pre-amplifier is defined as $A_v = g_m R_L$, changing $R_L$ on one side of the differential pair adjusts the output DC level. If the differential pair has an offset, the trimming network is adjusted to introduce an equal and opposite value to effectively zero the error. This technique is typically implemented using a binary-weighted bank of PMOS transistors as the variable resistance, where the digital control code is determined at startup and stored in a register.

\subsubsection{Resistive Reference Ladder Trimming}

The resistive reference ladder trimming technique corrects comparator offset by utilizing the main reference ladder as a calibration source \cite{yao_bulk_2011}. In this architecture, a switching network selects specific voltage taps from the resistor ladder and applies them to the bulk terminals of the input transistors M1 and M2. This approach leverages the body effect to shift the threshold voltage ($V_{th}$) of the differential pair, thereby nullifying the input-referred offset caused by process mismatch. 

As demonstrated in the simulation results of the threshold voltage ($|V_t|$) versus the ladder tap voltage ($LT$), the threshold voltage of transistors M1 and M2 increases linearly from approximately 356.5~mV to 372~mV as the calibration voltage is adjusted. In contrast, the threshold voltage of transistors M3 and M4 remains constant at approximately 356.5~mV because their bulk terminals are not connected to the tuning network. This targeted adjustment of the bulk potential for the input differential pair provides a tuning range sufficient to compensate for random process variations and ensure the accuracy of the comparator trip points.
\paragraph{}
\paragraph{}
\paragraph{}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth]{figures/VT bulk.png}
  \caption{Threshold voltage ($|V_t|$) variation of input differential pair transistors (M1, M2) and load transistors (M3, M4) as a function of the resistive ladder tap voltage ($LT$). The graph demonstrates the body effect: as the bulk potential of M1 and M2 is modulated via the reference ladder, their threshold voltage increases linearly, providing a calibration range to compensate for process-induced mismatch. In contrast, M3 and M4 maintain constant $V_{th}$ since their bulk terminals are connected to fixed substrate potential. This selective tuning is the basis of the proposed resistive ladder trimming mechanism \cite{yao_bulk_2011}.}
  \label{fig:mismatch_correction}
\end{figure}
\paragraph{}
\paragraph{}
\paragraph{}

\subsection{Advantages of Resistive Trimming for Asynchronous ADCs}
Compared to dynamic techniques like Auto-Zeroing which requires accurate clock phases $\phi_1, \phi_2$ and storage capacitors \cite{baker_cmos_2010}, resistive trimming offers distinct advantages for the proposed work:
\begin{enumerate}
  \item Static Operation: Once the calibration bits are set (during the offline phase), the trimming network becomes static. It does not switch and does not require a clock, preserving the ``event-driven'' nature of the ADC.
  \item Speed Preservation: It does not add significant capacitive load to the high-speed nodes of the comparator, allowing for maximum bandwidth.
\end{enumerate}

\section{Related Works} \label{sec:related_works}



As high-speed and low-power Analog-to-Digital Converters become increasingly critical for modern integrated systems, the Flash architecture remains a preferred choice due to its parallel operation and low latency. However, at high resolutions and speeds, transistor mismatch in the comparator array poses a significant challenge, leading to increased offset voltages. To address these limitations, various research efforts have focused on current-mode techniques and optimized comparator structures.

The research proposed in this dissertation differs from the established literature by focusing on an asynchronous level-crossing sampling Flash ADC, which deviates from the synchronous current-mode architectures. While most current-mode designs rely on specialized conveyors or algorithmic cycles, the approach developed here utilizes a bulk-driven offset trimming mechanism. By modulating the threshold voltage ($V_{th}$) via the body effect through a resistive reference ladder \cite{yao_bulk_2011}, this work achieves precise offset nullification without the high power overhead of complex biasing or the speed penalties of synchronous clocking. 

\section{Asynchronous vs. Synchronous}

\subsection{Advantage}
The primary motivation for adopting asynchronous architectures is the direct relationship between signal activity and power consumption \cite{lim_2013}.

In a synchronous system, the clock tree and the comparators switch at every clock cycle, regardless of whether the input is changing, the power consumption is dominated by the fixed clock frequency \cite{baker_cmos_2010}:
\begin{equation}
  P_{sync} \approx f_{clk} \cdot C_{total} \cdot V_{DD}^2
\end{equation}

In an asynchronous ADC, the switching frequency is replaced by the event rate. If the signal is constant or slowly varying, the comparators and digital logic remain static, leading to the following proportionality:
\begin{equation}
  P_{async} \propto Activity \times V_{DD}^2
\end{equation}
This property ensures that the energy consumed is always proportional to the information content of the signal which makes these ADCs significantly more efficient for sparse signal environments, where they can achieve near-zero power during periods of inactivity.

\subsection{Comparative Evaluation}
An analysis of state-of-the-art converters shows that asynchronous ADCs excel in energy efficiency across a wide range of sampling rates, particularly for low-to-medium bandwidths \cite{lim_2013}.

While Synchronous Flash ADCs are designed for peak performance at a specific frequency and suffer from a much higher power consumption caused by the continuous clocking, asynchronous designs scale their power consumption linearly with the input activity.

\begin{table}[h!]
\centering
\caption{Comparison of Power Consumption between Synchronous and Asynchronous Flash ADCs. Simulation results from this work showing the power advantage of asynchronous operation for sparse signals.}
\label{tab:adc_power_comparison}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Topology} & \textbf{Average power ($P$ [W])} & \textbf{No of samples} \\ \hline
Synchronous           & 0.1016                            & 145                      \\ \hline
Asynchronous         & 0.0314                            & 23                       \\ \hline
\end{tabular}
\end{table}

The impact of this architectural difference on long-term technology trends is illustrated in Figure \ref{fig:energy_evol}. The plot depicts the energy per conversion ($P/f_s$) over the last two decades. While both paradigms show a downward trend due to process node scaling, asynchronous designs (indicated by triangular markers) consistently occupy the lower bound of the energy envelope. This suggests that eliminating the global clock is a key enabler for breaking the power efficiency barriers in modern designs.

\par\vspace{1.5em}
\par\vspace{1.5em}
\par\vspace{1.5em}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.85\textwidth]{energy_year.png}
    \caption{Energy per conversion step vs. Year of publication (ISSCC dataset).}
    \label{fig:energy_year}
\end{figure}

\par\vspace{1.5em}
\par\vspace{1.5em}
\par\vspace{1.5em}

\begin{table}[htbp]
\centering
\caption{Energy per Conversion vs. Year (Flash reference [1] highlighted)}
\label{tab:energy_year}
\begin{tabular}{lllc}
\toprule
\textbf{Ref.} & \textbf{Architecture} & \textbf{Publication} & \textbf{Energy [pJ]} \\ \midrule
\textbf{[1]}  & \textbf{Flash}       & \textbf{Chen \cite{Chen_2006}} & \textbf{2.02} \\
{} [2]        & Sigma-Delta          & Jiang \cite{Jiang_2018}        & 0.059 \\
{} [3]        & Sigma-Delta          & Veldhoven \cite{Veldhoven_2021}& 0.070 \\
{} [4]        & SAR                  & Ginsburg \cite{Ginsburg_2014}  & 0.420 \\
{} [5]        & Sigma-Delta          & Kim \cite{Kim_2018}            & 0.703 \\ \bottomrule
\end{tabular}
\end{table}




% =================================================================
% FIM DO DOCUMENTO
% =================================================================
\chapter{Future Work Planning, Methodologies and Tools} \label{chap:planning}

This chapter outlines the development strategy for the dissertation, detailing the methodologies, tools, and the schedule for the remaining phases.

\section{Work Plan} \label{sec:workplan}
Since the work completed this far covers the introduction and the literature review, future planning focuses on the comprehensive development of the three remaining sections. Chapter 3 will be dedicated to the detailed architecture and the theoretical framework of the asynchronous level-crossing sampling and the bulk voltage trimming mechanism, establishing the necessary design parameters. Chapter 4 will involve the implementation, simulation, and discussion of the results, while Chapter 5 will present the final conclusions and suggestions for future work.

To complete the dissertation according to the established timeline and quality standards, a Gantt Chart is presented in Figure~\ref{fig:gantt_chart}. The second semester will begin on February 18, 2026, with a deep dive into the theoretical underpinnings of bulk-driven offset compensation, specifically focusing on the threshold voltage modulation via the body effect as discussed in the literature. This initial phase is critical to define the operating limits and calibration strategy of the system before transitioning to the physical implementation. This will be followed by the design and simulation of the asynchronous Flash ADC core and the resistive trimming network in the Cadence Virtuoso environment. Documentation of the technical operating principles will run in parallel with the design phase to ensure accuracy.

Once the circuit achieves basic functionality, Monte Carlo simulations will be performed to evaluate the robustness of the trimming algorithm against random process mismatches. Furthermore, the design will be validated across different process corners to ensure reliability under varying conditions. The results will then be analyzed to quantify improvements in linearity and energy efficiency. After the first version of the dissertation is finalized, a scientific research article will be prepared for submission. Regular meetings with the supervisors will be held throughout the process to ensure technical consistency. The provisional document will be delivered by June 30, 2026, with the defense scheduled for July 24, and the final document submission by July 31, 2026.\begin{figure}[htbp]
\centering
\resizebox{\textwidth}{!}{ % Forces alignment to page width
\begin{ganttchart}[
    hgrid,
    vgrid,
    x unit=0.55cm,
    y unit title=0.7cm,
    title height=1,
    progress label text={},
    group right shift=0,
    group top shift=0.7,
    group height=.3,
    group peaks tip position=0,
    newline shortcut=true,
    bar/.append style={fill=blue!20},
    milestone/.append style={fill=black}
]{1}{24} % Weeks from Feb 18 to July 31
    \gantttitle{2026}{24} \\
    \gantttitle{Feb}{2} 
    \gantttitle{Mar}{4} 
    \gantttitle{Apr}{4} 
    \gantttitle{May}{5} 
    \gantttitle{Jun}{4} 
    \gantttitle{Jul}{5} \\
    
    \ganttbar[name=T1]{Mathematical Formulation}{1}{4} \\
    \ganttbar[name=T2]{ADC Design \& Simulation}{4}{12} \\
    \ganttbar[name=T3]{Results Analysis (Ch. 4)}{12}{18} \\
    
    \ganttbar[name=T4]{Dissertation Final Writing}{16}{19} \\
    \ganttmilestone[name=M1]{Provisional Delivery (Jun 30)}{19} \\
    \ganttbar[name=T5]{Defense Preparation}{20}{22} \\
    \ganttmilestone[name=M2]{Dissertation Defense (Jul 24)}{23} \\
    \ganttmilestone[name=M3]{Final Submission (Jul 31)}{24}

    % The \ganttlink commands have been removed here
\end{ganttchart}
}
\caption{Dissertation work plan for the second semester of 2026.}
\label{fig:gantt_chart}
\end{figure}
The second semester will begin on February 18, 2026, with the development of the mathematical model for bulk-driven offset compensation, specifically focusing on the threshold voltage modulation via the body effect as discussed in the literature. This will be followed by the design and simulation of the asynchronous Flash ADC core and the resistive trimming network in the Cadence Virtuoso environment. Once the circuit achieves basic functionality, Monte Carlo simulations will be performed to evaluate the robustness of the trimming algorithm against random process mismatches. The results will then be analyzed to quantify improvements in linearity and energy efficiency. After the first version of the dissertation is finalized, a scientific research article will be prepared for submission. Regular meetings with the supervisors will be held throughout the process to ensure technical consistency. The provisional document will be delivered by June 30, 2026, with the defense scheduled for July 24, and the final document submission by July 31, 2026.
\section{Methodologies and Tools} \label{sec:tools}
The execution of this dissertation follows a methodology focused on academic rigor and effective project management to ensure all objectives are met. A primary practice involves the use of project management tools such as the Gantt chart presented in Figure \ref{fig:gantt_chart} to establish clear milestones and monitor progress. By defining specific tasks and deadlines, it is possible to maintain a structured timeline and ensure that the research and design phases stay on schedule. Another fundamental practice consists of holding biweekly meetings with supervisors to review the work carried out and receive technical feedback. These sessions are essential for validating the circuit design choices and avoiding potential errors in the implementation of the asynchronous logic. Continuous documentation of the findings and simulation results is also prioritized to maintain transparency and facilitate the transition from the research phase to the final writing of the document.

For the development and verification of the proposed asynchronous Flash ADC, the Synopsys software will be used as the primary tool for circuit-level design and simulation. This professional toolset allows for precise transistor-level modeling and the verification of the offset trimming mechanism through analog and mixed-signal simulations. 

% =================================================================
% CHAPTER 4: CONCLUSIONS
% =================================================================
\chapter{Conclusions} \label{chap:conclusions}
The work conducted during the first semester has been essential for establishing the technical and theoretical foundations of this dissertation. The increasing demand for high-speed, low-power ADCs in modern system on chip applications drives the need for innovative architectures that can overcome the limitations of traditional designs. In this context, the research into an asynchronous level-crossing sampling Flash ADC with bulk-driven offset trimming can significantly contribute to the development of more efficient data conversion systems for high-bandwidth applications.

A variety of ADC architectures and comparator topologies have been deeply studied to understand their performance trade-offs. The Flash architecture is recognized for its parallel processing capabilities, but its accuracy is often limited by transistor mismatch, which necessitates effective calibration or trimming techniques. Current-mode techniques have been explored as a means to achieve higher speeds and lower power consumption compared to traditional voltage-mode designs. Furthermore, the study of dynamic latch comparators and current conveyors has provided insights into optimizing the delay profile and power dissipation of the conversion core. This research has highlighted that asynchronous level-crossing sampling can reduce the power overhead associated with global clocks, especially during periods of signal inactivity. To address the mismatch inherent in these high-speed comparators, a bulk-driven trimming mechanism utilizing the body effect is proposed, allowing for precise threshold voltage modulation without adding significant parasitic capacitance.

An extensive investigation of existing studies in this field was conducted to ensure the acquisition of the knowledge necessary to develop the mathematical formulation of the proposed system. The bibliographic review confirmed that while current-mode and inverter-based comparators offer high performance, there is a clear opportunity to integrate them into an asynchronous framework with localized trimming. Once the mathematical model for the bulk potential adjustment is finalized, the main challenge ahead will be to prove the effectiveness and robustness of the proposed approach using Synopsys simulation tools. A rigorous analysis through Monte Carlo simulations will be pursued to validate the trimming algorithm against process variations, ensuring a successful trade-off between conversion speed, power efficiency, and linearity.